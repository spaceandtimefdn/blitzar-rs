// Copyright 2023-present Space and Time Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use ark_bn254::{Fr, G1Affine, G1Projective};
use ark_ec::{CurveGroup, VariableBaseMSM};
use ark_std::UniformRand;
use blitzar::compute::*;

fn main() {
    /////////////////////////////////////////////
    // For the following data, we have:
    //     commitment[0] = gs[0]*data[0] + gs[1]*data[1] + gs[2]*data[2] + gs[3]*data[3]
    //
    // Those generators `gs` are automatically generated by our CPU/GPU code.
    // So we provide an interface to access them. We use the offset to get only
    // a subset of the generators used in the gpu/cpu code.
    //
    // Alternatively, in this example, we provide a generator vector `gs`.
    /////////////////////////////////////////////
    let data: Vec<u16> = vec![2, 3, 1, 5, 4, 7, 6, 8, 9, 10];

    /////////////////////////////////////////////
    // randomly obtain the generator points
    /////////////////////////////////////////////
    let mut rng = ark_std::test_rng();
    let generator_points: Vec<G1Affine> =
        (0..data.len()).map(|_| G1Affine::rand(&mut rng)).collect();

    /////////////////////////////////////////////
    // Do the actual commitment computation
    /////////////////////////////////////////////
    let mut commitments = vec![G1Affine::default(); 1];
    compute_bn254_g1_uncompressed_commitments_with_generators(
        &mut commitments,
        &[(&data).into()],
        &generator_points,
    );

    /////////////////////////////////////////////
    // Then we use the above generators `gs`,
    // as well as the data as scalars
    // to verify that those generators `gs`
    // are indeed the ones used during the
    // commitment computation
    /////////////////////////////////////////////
    let mut scalar_data: Vec<Fr> = Vec::new();
    for d in &data {
        scalar_data.push(Fr::from(*d));
    }
    let ark_commitment = G1Projective::msm(&generator_points, &scalar_data).unwrap();

    /////////////////////////////////////////////
    // Compare Arkworks and our CPU/GPU commitment
    /////////////////////////////////////////////
    println!("Computed Commitment: {:?}\n", commitments[0]);
    println!("Expected Commitment: {:?}\n", ark_commitment.into_affine());
}
