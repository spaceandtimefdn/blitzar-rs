// Copyright 2023-present Space and Time Labs, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
use ark_grumpkin::{Affine, Fr, Projective};
// use ark_ec::{CurveGroup, VariableBaseMSM};
use ark_std::UniformRand;

extern crate blitzar;
use blitzar::compute::*;

fn main() {
    /////////////////////////////////////////////
    // For the following data, we have:
    //     commitment[0] = gs[0]*data[0] + gs[1]*data[1] + gs[2]*data[2] + gs[3]*data[3]
    //
    // Those generators `gs` are automatically generated by our CPU/GPU code.
    // So we provide an interface to access them. We use the offset to get only
    // a subset of the generators used in the gpu/cpu code.
    //
    // Alternatively, in this example, we provide a generator vector `gs`.
    /////////////////////////////////////////////
    let data: Vec<u16> = vec![2, 3, 1, 5, 4, 7, 6, 8, 9, 10];

    /////////////////////////////////////////////
    // randomly obtain the generator points
    /////////////////////////////////////////////
    let mut rng = ark_std::test_rng();
    let generator_points: Vec<Affine> = (0..data.len()).map(|_| Affine::rand(&mut rng)).collect();

    /////////////////////////////////////////////
    // Do the actual commitment computation
    /////////////////////////////////////////////
    let mut commitments = vec![Affine::default(); 1];
    compute_grumpkin_uncompressed_commitments_with_generators(
        &mut commitments,
        &[(&data).into()],
        &generator_points,
    );

    /////////////////////////////////////////////
    // Then we use the above generators `gs`,
    // as well as the data as scalars
    // to verify that those generators `gs`
    // are indeed the ones used during the
    // commitment computation
    /////////////////////////////////////////////
    let mut scalar_data: Vec<Fr> = Vec::new();
    for d in &data {
        scalar_data.push(Fr::from(*d));
    }

    /////////////////////////////////////////////////////////////////////////////////////////
    //// ERROR msm - function or associated item not found in `Projective<GrumpkinConfig>` //
    /////////////////////////////////////////////////////////////////////////////////////////
    // let ark_commitment = Projective::msm(&generator_points, &scalar_data).unwrap();
    /////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////////////////
    let mut ark_commitment = Projective::default();
    for (&point, &scalar) in generator_points.iter().zip(scalar_data.iter()) {
        let mul_result = point * scalar;
        ark_commitment += mul_result;
    }

    /////////////////////////////////////////////////////////////////////////////////////
    // ark_commitment.into_affine() - method not found in `Projective<GrumpkinConfig>` //
    /////////////////////////////////////////////////////////////////////////////////////
    let z2 = ark_commitment.z * ark_commitment.z;
    let z3 = z2 * ark_commitment.z;
    let x = ark_commitment.x / z2;
    let y = ark_commitment.y / z3;
    let ark_commitment_affine = Affine::new(x, y);

    /////////////////////////////////////////////
    // Compare Arkworks and our CPU/GPU commitment
    /////////////////////////////////////////////
    println!("Computed Commitment: {:?}\n", commitments[0]);
    println!("Expected Commitment: {:?}\n", ark_commitment_affine);
}
